// Code generated by ogen, DO NOT EDIT.

package mediamtx

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/uri"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AuthJwksRefresh invokes authJwksRefresh operation.
	//
	// Manually refreshes the JWT JWKS.
	//
	// POST /v3/auth/jwks/refresh
	AuthJwksRefresh(ctx context.Context) (AuthJwksRefreshRes, error)
	// ConfigGlobalGet invokes configGlobalGet operation.
	//
	// Returns the global configuration.
	//
	// GET /v3/config/global/get
	ConfigGlobalGet(ctx context.Context) (ConfigGlobalGetRes, error)
	// ConfigGlobalSet invokes configGlobalSet operation.
	//
	// All fields are optional.
	//
	// PATCH /v3/config/global/patch
	ConfigGlobalSet(ctx context.Context, request *GlobalConf) (ConfigGlobalSetRes, error)
	// ConfigPathDefaultsGet invokes configPathDefaultsGet operation.
	//
	// Returns the default path configuration.
	//
	// GET /v3/config/pathdefaults/get
	ConfigPathDefaultsGet(ctx context.Context) (ConfigPathDefaultsGetRes, error)
	// ConfigPathDefaultsPatch invokes configPathDefaultsPatch operation.
	//
	// All fields are optional.
	//
	// PATCH /v3/config/pathdefaults/patch
	ConfigPathDefaultsPatch(ctx context.Context, request *PathConf) (ConfigPathDefaultsPatchRes, error)
	// ConfigPathsAdd invokes configPathsAdd operation.
	//
	// All fields are optional.
	//
	// POST /v3/config/paths/add/{name}
	ConfigPathsAdd(ctx context.Context, request *PathConf, params ConfigPathsAddParams) (ConfigPathsAddRes, error)
	// ConfigPathsDelete invokes configPathsDelete operation.
	//
	// Removes a path configuration.
	//
	// DELETE /v3/config/paths/delete/{name}
	ConfigPathsDelete(ctx context.Context, params ConfigPathsDeleteParams) (ConfigPathsDeleteRes, error)
	// ConfigPathsGet invokes configPathsGet operation.
	//
	// Returns a path configuration.
	//
	// GET /v3/config/paths/get/{name}
	ConfigPathsGet(ctx context.Context, params ConfigPathsGetParams) (ConfigPathsGetRes, error)
	// ConfigPathsList invokes configPathsList operation.
	//
	// Returns all path configurations.
	//
	// GET /v3/config/paths/list
	ConfigPathsList(ctx context.Context, params ConfigPathsListParams) (ConfigPathsListRes, error)
	// ConfigPathsPatch invokes configPathsPatch operation.
	//
	// All fields are optional.
	//
	// PATCH /v3/config/paths/patch/{name}
	ConfigPathsPatch(ctx context.Context, request *PathConf, params ConfigPathsPatchParams) (ConfigPathsPatchRes, error)
	// ConfigPathsReplace invokes configPathsReplace operation.
	//
	// All fields are optional.
	//
	// POST /v3/config/paths/replace/{name}
	ConfigPathsReplace(ctx context.Context, request *PathConf, params ConfigPathsReplaceParams) (ConfigPathsReplaceRes, error)
	// HlsMuxersGet invokes hlsMuxersGet operation.
	//
	// Returns a HLS muxer.
	//
	// GET /v3/hlsmuxers/get/{name}
	HlsMuxersGet(ctx context.Context, params HlsMuxersGetParams) (HlsMuxersGetRes, error)
	// HlsMuxersList invokes hlsMuxersList operation.
	//
	// Returns all HLS muxers.
	//
	// GET /v3/hlsmuxers/list
	HlsMuxersList(ctx context.Context, params HlsMuxersListParams) (HlsMuxersListRes, error)
	// PathsGet invokes pathsGet operation.
	//
	// Returns a path.
	//
	// GET /v3/paths/get/{name}
	PathsGet(ctx context.Context, params PathsGetParams) (PathsGetRes, error)
	// PathsList invokes pathsList operation.
	//
	// Returns all paths.
	//
	// GET /v3/paths/list
	PathsList(ctx context.Context, params PathsListParams) (PathsListRes, error)
	// RecordingsDeleteSegment invokes recordingsDeleteSegment operation.
	//
	// Deletes a recording segment.
	//
	// DELETE /v3/recordings/deletesegment
	RecordingsDeleteSegment(ctx context.Context, params RecordingsDeleteSegmentParams) (RecordingsDeleteSegmentRes, error)
	// RecordingsGet invokes recordingsGet operation.
	//
	// Returns recordings for a path.
	//
	// GET /v3/recordings/get/{name}
	RecordingsGet(ctx context.Context, params RecordingsGetParams) (RecordingsGetRes, error)
	// RecordingsList invokes recordingsList operation.
	//
	// Returns all recordings.
	//
	// GET /v3/recordings/list
	RecordingsList(ctx context.Context, params RecordingsListParams) (RecordingsListRes, error)
	// RtmpConnectionsGet invokes rtmpConnectionsGet operation.
	//
	// Returns a RTMP connection.
	//
	// GET /v3/rtmpconns/get/{id}
	RtmpConnectionsGet(ctx context.Context, params RtmpConnectionsGetParams) (RtmpConnectionsGetRes, error)
	// RtmpConnsKick invokes rtmpConnsKick operation.
	//
	// Kicks out a RTMP connection from the server.
	//
	// POST /v3/rtmpconns/kick/{id}
	RtmpConnsKick(ctx context.Context, params RtmpConnsKickParams) (RtmpConnsKickRes, error)
	// RtmpConnsList invokes rtmpConnsList operation.
	//
	// Returns all RTMP connections.
	//
	// GET /v3/rtmpconns/list
	RtmpConnsList(ctx context.Context, params RtmpConnsListParams) (RtmpConnsListRes, error)
	// RtmpsConnectionsGet invokes rtmpsConnectionsGet operation.
	//
	// Returns a RTMPS connection.
	//
	// GET /v3/rtmpsconns/get/{id}
	RtmpsConnectionsGet(ctx context.Context, params RtmpsConnectionsGetParams) (RtmpsConnectionsGetRes, error)
	// RtmpsConnsKick invokes rtmpsConnsKick operation.
	//
	// Kicks out a RTMPS connection from the server.
	//
	// POST /v3/rtmpsconns/kick/{id}
	RtmpsConnsKick(ctx context.Context, params RtmpsConnsKickParams) (RtmpsConnsKickRes, error)
	// RtmpsConnsList invokes rtmpsConnsList operation.
	//
	// Returns all RTMPS connections.
	//
	// GET /v3/rtmpsconns/list
	RtmpsConnsList(ctx context.Context, params RtmpsConnsListParams) (RtmpsConnsListRes, error)
	// RtspConnsGet invokes rtspConnsGet operation.
	//
	// Returns a RTSP connection.
	//
	// GET /v3/rtspconns/get/{id}
	RtspConnsGet(ctx context.Context, params RtspConnsGetParams) (RtspConnsGetRes, error)
	// RtspConnsList invokes rtspConnsList operation.
	//
	// Returns all RTSP connections.
	//
	// GET /v3/rtspconns/list
	RtspConnsList(ctx context.Context, params RtspConnsListParams) (RtspConnsListRes, error)
	// RtspSessionsGet invokes rtspSessionsGet operation.
	//
	// Returns a RTSP session.
	//
	// GET /v3/rtspsessions/get/{id}
	RtspSessionsGet(ctx context.Context, params RtspSessionsGetParams) (RtspSessionsGetRes, error)
	// RtspSessionsKick invokes rtspSessionsKick operation.
	//
	// Kicks out a RTSP session from the server.
	//
	// POST /v3/rtspsessions/kick/{id}
	RtspSessionsKick(ctx context.Context, params RtspSessionsKickParams) (RtspSessionsKickRes, error)
	// RtspSessionsList invokes rtspSessionsList operation.
	//
	// Returns all RTSP sessions.
	//
	// GET /v3/rtspsessions/list
	RtspSessionsList(ctx context.Context, params RtspSessionsListParams) (RtspSessionsListRes, error)
	// RtspsConnsGet invokes rtspsConnsGet operation.
	//
	// Returns a RTSPS connection.
	//
	// GET /v3/rtspsconns/get/{id}
	RtspsConnsGet(ctx context.Context, params RtspsConnsGetParams) (RtspsConnsGetRes, error)
	// RtspsConnsList invokes rtspsConnsList operation.
	//
	// Returns all RTSPS connections.
	//
	// GET /v3/rtspsconns/list
	RtspsConnsList(ctx context.Context, params RtspsConnsListParams) (RtspsConnsListRes, error)
	// RtspsSessionsGet invokes rtspsSessionsGet operation.
	//
	// Returns a RTSPS session.
	//
	// GET /v3/rtspssessions/get/{id}
	RtspsSessionsGet(ctx context.Context, params RtspsSessionsGetParams) (RtspsSessionsGetRes, error)
	// RtspsSessionsKick invokes rtspsSessionsKick operation.
	//
	// Kicks out a RTSPS session from the server.
	//
	// POST /v3/rtspssessions/kick/{id}
	RtspsSessionsKick(ctx context.Context, params RtspsSessionsKickParams) (RtspsSessionsKickRes, error)
	// RtspsSessionsList invokes rtspsSessionsList operation.
	//
	// Returns all RTSPS sessions.
	//
	// GET /v3/rtspssessions/list
	RtspsSessionsList(ctx context.Context, params RtspsSessionsListParams) (RtspsSessionsListRes, error)
	// SrtConnsGet invokes srtConnsGet operation.
	//
	// Returns a SRT connection.
	//
	// GET /v3/srtconns/get/{id}
	SrtConnsGet(ctx context.Context, params SrtConnsGetParams) (SrtConnsGetRes, error)
	// SrtConnsKick invokes srtConnsKick operation.
	//
	// Kicks out a SRT connection from the server.
	//
	// POST /v3/srtconns/kick/{id}
	SrtConnsKick(ctx context.Context, params SrtConnsKickParams) (SrtConnsKickRes, error)
	// SrtConnsList invokes srtConnsList operation.
	//
	// Returns all SRT connections.
	//
	// GET /v3/srtconns/list
	SrtConnsList(ctx context.Context, params SrtConnsListParams) (SrtConnsListRes, error)
	// WebrtcSessionsGet invokes webrtcSessionsGet operation.
	//
	// Returns a WebRTC session.
	//
	// GET /v3/webrtcsessions/get/{id}
	WebrtcSessionsGet(ctx context.Context, params WebrtcSessionsGetParams) (WebrtcSessionsGetRes, error)
	// WebrtcSessionsKick invokes webrtcSessionsKick operation.
	//
	// Kicks out a WebRTC session from the server.
	//
	// POST /v3/webrtcsessions/kick/{id}
	WebrtcSessionsKick(ctx context.Context, params WebrtcSessionsKickParams) (WebrtcSessionsKickRes, error)
	// WebrtcSessionsList invokes webrtcSessionsList operation.
	//
	// Returns all WebRTC sessions.
	//
	// GET /v3/webrtcsessions/list
	WebrtcSessionsList(ctx context.Context, params WebrtcSessionsListParams) (WebrtcSessionsListRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AuthJwksRefresh invokes authJwksRefresh operation.
//
// Manually refreshes the JWT JWKS.
//
// POST /v3/auth/jwks/refresh
func (c *Client) AuthJwksRefresh(ctx context.Context) (AuthJwksRefreshRes, error) {
	res, err := c.sendAuthJwksRefresh(ctx)
	return res, err
}

func (c *Client) sendAuthJwksRefresh(ctx context.Context) (res AuthJwksRefreshRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/auth/jwks/refresh"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthJwksRefreshResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigGlobalGet invokes configGlobalGet operation.
//
// Returns the global configuration.
//
// GET /v3/config/global/get
func (c *Client) ConfigGlobalGet(ctx context.Context) (ConfigGlobalGetRes, error) {
	res, err := c.sendConfigGlobalGet(ctx)
	return res, err
}

func (c *Client) sendConfigGlobalGet(ctx context.Context) (res ConfigGlobalGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/config/global/get"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigGlobalGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigGlobalSet invokes configGlobalSet operation.
//
// All fields are optional.
//
// PATCH /v3/config/global/patch
func (c *Client) ConfigGlobalSet(ctx context.Context, request *GlobalConf) (ConfigGlobalSetRes, error) {
	res, err := c.sendConfigGlobalSet(ctx, request)
	return res, err
}

func (c *Client) sendConfigGlobalSet(ctx context.Context, request *GlobalConf) (res ConfigGlobalSetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/config/global/patch"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeConfigGlobalSetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigGlobalSetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigPathDefaultsGet invokes configPathDefaultsGet operation.
//
// Returns the default path configuration.
//
// GET /v3/config/pathdefaults/get
func (c *Client) ConfigPathDefaultsGet(ctx context.Context) (ConfigPathDefaultsGetRes, error) {
	res, err := c.sendConfigPathDefaultsGet(ctx)
	return res, err
}

func (c *Client) sendConfigPathDefaultsGet(ctx context.Context) (res ConfigPathDefaultsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/config/pathdefaults/get"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigPathDefaultsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigPathDefaultsPatch invokes configPathDefaultsPatch operation.
//
// All fields are optional.
//
// PATCH /v3/config/pathdefaults/patch
func (c *Client) ConfigPathDefaultsPatch(ctx context.Context, request *PathConf) (ConfigPathDefaultsPatchRes, error) {
	res, err := c.sendConfigPathDefaultsPatch(ctx, request)
	return res, err
}

func (c *Client) sendConfigPathDefaultsPatch(ctx context.Context, request *PathConf) (res ConfigPathDefaultsPatchRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/config/pathdefaults/patch"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeConfigPathDefaultsPatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigPathDefaultsPatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigPathsAdd invokes configPathsAdd operation.
//
// All fields are optional.
//
// POST /v3/config/paths/add/{name}
func (c *Client) ConfigPathsAdd(ctx context.Context, request *PathConf, params ConfigPathsAddParams) (ConfigPathsAddRes, error) {
	res, err := c.sendConfigPathsAdd(ctx, request, params)
	return res, err
}

func (c *Client) sendConfigPathsAdd(ctx context.Context, request *PathConf, params ConfigPathsAddParams) (res ConfigPathsAddRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/config/paths/add/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeConfigPathsAddRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigPathsAddResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigPathsDelete invokes configPathsDelete operation.
//
// Removes a path configuration.
//
// DELETE /v3/config/paths/delete/{name}
func (c *Client) ConfigPathsDelete(ctx context.Context, params ConfigPathsDeleteParams) (ConfigPathsDeleteRes, error) {
	res, err := c.sendConfigPathsDelete(ctx, params)
	return res, err
}

func (c *Client) sendConfigPathsDelete(ctx context.Context, params ConfigPathsDeleteParams) (res ConfigPathsDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/config/paths/delete/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigPathsDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigPathsGet invokes configPathsGet operation.
//
// Returns a path configuration.
//
// GET /v3/config/paths/get/{name}
func (c *Client) ConfigPathsGet(ctx context.Context, params ConfigPathsGetParams) (ConfigPathsGetRes, error) {
	res, err := c.sendConfigPathsGet(ctx, params)
	return res, err
}

func (c *Client) sendConfigPathsGet(ctx context.Context, params ConfigPathsGetParams) (res ConfigPathsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/config/paths/get/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigPathsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigPathsList invokes configPathsList operation.
//
// Returns all path configurations.
//
// GET /v3/config/paths/list
func (c *Client) ConfigPathsList(ctx context.Context, params ConfigPathsListParams) (ConfigPathsListRes, error) {
	res, err := c.sendConfigPathsList(ctx, params)
	return res, err
}

func (c *Client) sendConfigPathsList(ctx context.Context, params ConfigPathsListParams) (res ConfigPathsListRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/config/paths/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "itemsPerPage" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ItemsPerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigPathsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigPathsPatch invokes configPathsPatch operation.
//
// All fields are optional.
//
// PATCH /v3/config/paths/patch/{name}
func (c *Client) ConfigPathsPatch(ctx context.Context, request *PathConf, params ConfigPathsPatchParams) (ConfigPathsPatchRes, error) {
	res, err := c.sendConfigPathsPatch(ctx, request, params)
	return res, err
}

func (c *Client) sendConfigPathsPatch(ctx context.Context, request *PathConf, params ConfigPathsPatchParams) (res ConfigPathsPatchRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/config/paths/patch/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeConfigPathsPatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigPathsPatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigPathsReplace invokes configPathsReplace operation.
//
// All fields are optional.
//
// POST /v3/config/paths/replace/{name}
func (c *Client) ConfigPathsReplace(ctx context.Context, request *PathConf, params ConfigPathsReplaceParams) (ConfigPathsReplaceRes, error) {
	res, err := c.sendConfigPathsReplace(ctx, request, params)
	return res, err
}

func (c *Client) sendConfigPathsReplace(ctx context.Context, request *PathConf, params ConfigPathsReplaceParams) (res ConfigPathsReplaceRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/config/paths/replace/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeConfigPathsReplaceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConfigPathsReplaceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HlsMuxersGet invokes hlsMuxersGet operation.
//
// Returns a HLS muxer.
//
// GET /v3/hlsmuxers/get/{name}
func (c *Client) HlsMuxersGet(ctx context.Context, params HlsMuxersGetParams) (HlsMuxersGetRes, error) {
	res, err := c.sendHlsMuxersGet(ctx, params)
	return res, err
}

func (c *Client) sendHlsMuxersGet(ctx context.Context, params HlsMuxersGetParams) (res HlsMuxersGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/hlsmuxers/get/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHlsMuxersGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HlsMuxersList invokes hlsMuxersList operation.
//
// Returns all HLS muxers.
//
// GET /v3/hlsmuxers/list
func (c *Client) HlsMuxersList(ctx context.Context, params HlsMuxersListParams) (HlsMuxersListRes, error) {
	res, err := c.sendHlsMuxersList(ctx, params)
	return res, err
}

func (c *Client) sendHlsMuxersList(ctx context.Context, params HlsMuxersListParams) (res HlsMuxersListRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/hlsmuxers/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "itemsPerPage" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ItemsPerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHlsMuxersListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PathsGet invokes pathsGet operation.
//
// Returns a path.
//
// GET /v3/paths/get/{name}
func (c *Client) PathsGet(ctx context.Context, params PathsGetParams) (PathsGetRes, error) {
	res, err := c.sendPathsGet(ctx, params)
	return res, err
}

func (c *Client) sendPathsGet(ctx context.Context, params PathsGetParams) (res PathsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/paths/get/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePathsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PathsList invokes pathsList operation.
//
// Returns all paths.
//
// GET /v3/paths/list
func (c *Client) PathsList(ctx context.Context, params PathsListParams) (PathsListRes, error) {
	res, err := c.sendPathsList(ctx, params)
	return res, err
}

func (c *Client) sendPathsList(ctx context.Context, params PathsListParams) (res PathsListRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/paths/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "itemsPerPage" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ItemsPerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePathsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RecordingsDeleteSegment invokes recordingsDeleteSegment operation.
//
// Deletes a recording segment.
//
// DELETE /v3/recordings/deletesegment
func (c *Client) RecordingsDeleteSegment(ctx context.Context, params RecordingsDeleteSegmentParams) (RecordingsDeleteSegmentRes, error) {
	res, err := c.sendRecordingsDeleteSegment(ctx, params)
	return res, err
}

func (c *Client) sendRecordingsDeleteSegment(ctx context.Context, params RecordingsDeleteSegmentParams) (res RecordingsDeleteSegmentRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/recordings/deletesegment"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "path" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Start))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRecordingsDeleteSegmentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RecordingsGet invokes recordingsGet operation.
//
// Returns recordings for a path.
//
// GET /v3/recordings/get/{name}
func (c *Client) RecordingsGet(ctx context.Context, params RecordingsGetParams) (RecordingsGetRes, error) {
	res, err := c.sendRecordingsGet(ctx, params)
	return res, err
}

func (c *Client) sendRecordingsGet(ctx context.Context, params RecordingsGetParams) (res RecordingsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/recordings/get/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRecordingsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RecordingsList invokes recordingsList operation.
//
// Returns all recordings.
//
// GET /v3/recordings/list
func (c *Client) RecordingsList(ctx context.Context, params RecordingsListParams) (RecordingsListRes, error) {
	res, err := c.sendRecordingsList(ctx, params)
	return res, err
}

func (c *Client) sendRecordingsList(ctx context.Context, params RecordingsListParams) (res RecordingsListRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/recordings/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "itemsPerPage" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ItemsPerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRecordingsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RtmpConnectionsGet invokes rtmpConnectionsGet operation.
//
// Returns a RTMP connection.
//
// GET /v3/rtmpconns/get/{id}
func (c *Client) RtmpConnectionsGet(ctx context.Context, params RtmpConnectionsGetParams) (RtmpConnectionsGetRes, error) {
	res, err := c.sendRtmpConnectionsGet(ctx, params)
	return res, err
}

func (c *Client) sendRtmpConnectionsGet(ctx context.Context, params RtmpConnectionsGetParams) (res RtmpConnectionsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/rtmpconns/get/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRtmpConnectionsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RtmpConnsKick invokes rtmpConnsKick operation.
//
// Kicks out a RTMP connection from the server.
//
// POST /v3/rtmpconns/kick/{id}
func (c *Client) RtmpConnsKick(ctx context.Context, params RtmpConnsKickParams) (RtmpConnsKickRes, error) {
	res, err := c.sendRtmpConnsKick(ctx, params)
	return res, err
}

func (c *Client) sendRtmpConnsKick(ctx context.Context, params RtmpConnsKickParams) (res RtmpConnsKickRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/rtmpconns/kick/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRtmpConnsKickResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RtmpConnsList invokes rtmpConnsList operation.
//
// Returns all RTMP connections.
//
// GET /v3/rtmpconns/list
func (c *Client) RtmpConnsList(ctx context.Context, params RtmpConnsListParams) (RtmpConnsListRes, error) {
	res, err := c.sendRtmpConnsList(ctx, params)
	return res, err
}

func (c *Client) sendRtmpConnsList(ctx context.Context, params RtmpConnsListParams) (res RtmpConnsListRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/rtmpconns/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "itemsPerPage" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ItemsPerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRtmpConnsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RtmpsConnectionsGet invokes rtmpsConnectionsGet operation.
//
// Returns a RTMPS connection.
//
// GET /v3/rtmpsconns/get/{id}
func (c *Client) RtmpsConnectionsGet(ctx context.Context, params RtmpsConnectionsGetParams) (RtmpsConnectionsGetRes, error) {
	res, err := c.sendRtmpsConnectionsGet(ctx, params)
	return res, err
}

func (c *Client) sendRtmpsConnectionsGet(ctx context.Context, params RtmpsConnectionsGetParams) (res RtmpsConnectionsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/rtmpsconns/get/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRtmpsConnectionsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RtmpsConnsKick invokes rtmpsConnsKick operation.
//
// Kicks out a RTMPS connection from the server.
//
// POST /v3/rtmpsconns/kick/{id}
func (c *Client) RtmpsConnsKick(ctx context.Context, params RtmpsConnsKickParams) (RtmpsConnsKickRes, error) {
	res, err := c.sendRtmpsConnsKick(ctx, params)
	return res, err
}

func (c *Client) sendRtmpsConnsKick(ctx context.Context, params RtmpsConnsKickParams) (res RtmpsConnsKickRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/rtmpsconns/kick/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRtmpsConnsKickResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RtmpsConnsList invokes rtmpsConnsList operation.
//
// Returns all RTMPS connections.
//
// GET /v3/rtmpsconns/list
func (c *Client) RtmpsConnsList(ctx context.Context, params RtmpsConnsListParams) (RtmpsConnsListRes, error) {
	res, err := c.sendRtmpsConnsList(ctx, params)
	return res, err
}

func (c *Client) sendRtmpsConnsList(ctx context.Context, params RtmpsConnsListParams) (res RtmpsConnsListRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/rtmpsconns/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "itemsPerPage" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ItemsPerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRtmpsConnsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RtspConnsGet invokes rtspConnsGet operation.
//
// Returns a RTSP connection.
//
// GET /v3/rtspconns/get/{id}
func (c *Client) RtspConnsGet(ctx context.Context, params RtspConnsGetParams) (RtspConnsGetRes, error) {
	res, err := c.sendRtspConnsGet(ctx, params)
	return res, err
}

func (c *Client) sendRtspConnsGet(ctx context.Context, params RtspConnsGetParams) (res RtspConnsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/rtspconns/get/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRtspConnsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RtspConnsList invokes rtspConnsList operation.
//
// Returns all RTSP connections.
//
// GET /v3/rtspconns/list
func (c *Client) RtspConnsList(ctx context.Context, params RtspConnsListParams) (RtspConnsListRes, error) {
	res, err := c.sendRtspConnsList(ctx, params)
	return res, err
}

func (c *Client) sendRtspConnsList(ctx context.Context, params RtspConnsListParams) (res RtspConnsListRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/rtspconns/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "itemsPerPage" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ItemsPerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRtspConnsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RtspSessionsGet invokes rtspSessionsGet operation.
//
// Returns a RTSP session.
//
// GET /v3/rtspsessions/get/{id}
func (c *Client) RtspSessionsGet(ctx context.Context, params RtspSessionsGetParams) (RtspSessionsGetRes, error) {
	res, err := c.sendRtspSessionsGet(ctx, params)
	return res, err
}

func (c *Client) sendRtspSessionsGet(ctx context.Context, params RtspSessionsGetParams) (res RtspSessionsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/rtspsessions/get/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRtspSessionsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RtspSessionsKick invokes rtspSessionsKick operation.
//
// Kicks out a RTSP session from the server.
//
// POST /v3/rtspsessions/kick/{id}
func (c *Client) RtspSessionsKick(ctx context.Context, params RtspSessionsKickParams) (RtspSessionsKickRes, error) {
	res, err := c.sendRtspSessionsKick(ctx, params)
	return res, err
}

func (c *Client) sendRtspSessionsKick(ctx context.Context, params RtspSessionsKickParams) (res RtspSessionsKickRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/rtspsessions/kick/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRtspSessionsKickResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RtspSessionsList invokes rtspSessionsList operation.
//
// Returns all RTSP sessions.
//
// GET /v3/rtspsessions/list
func (c *Client) RtspSessionsList(ctx context.Context, params RtspSessionsListParams) (RtspSessionsListRes, error) {
	res, err := c.sendRtspSessionsList(ctx, params)
	return res, err
}

func (c *Client) sendRtspSessionsList(ctx context.Context, params RtspSessionsListParams) (res RtspSessionsListRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/rtspsessions/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "itemsPerPage" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ItemsPerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRtspSessionsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RtspsConnsGet invokes rtspsConnsGet operation.
//
// Returns a RTSPS connection.
//
// GET /v3/rtspsconns/get/{id}
func (c *Client) RtspsConnsGet(ctx context.Context, params RtspsConnsGetParams) (RtspsConnsGetRes, error) {
	res, err := c.sendRtspsConnsGet(ctx, params)
	return res, err
}

func (c *Client) sendRtspsConnsGet(ctx context.Context, params RtspsConnsGetParams) (res RtspsConnsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/rtspsconns/get/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRtspsConnsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RtspsConnsList invokes rtspsConnsList operation.
//
// Returns all RTSPS connections.
//
// GET /v3/rtspsconns/list
func (c *Client) RtspsConnsList(ctx context.Context, params RtspsConnsListParams) (RtspsConnsListRes, error) {
	res, err := c.sendRtspsConnsList(ctx, params)
	return res, err
}

func (c *Client) sendRtspsConnsList(ctx context.Context, params RtspsConnsListParams) (res RtspsConnsListRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/rtspsconns/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "itemsPerPage" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ItemsPerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRtspsConnsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RtspsSessionsGet invokes rtspsSessionsGet operation.
//
// Returns a RTSPS session.
//
// GET /v3/rtspssessions/get/{id}
func (c *Client) RtspsSessionsGet(ctx context.Context, params RtspsSessionsGetParams) (RtspsSessionsGetRes, error) {
	res, err := c.sendRtspsSessionsGet(ctx, params)
	return res, err
}

func (c *Client) sendRtspsSessionsGet(ctx context.Context, params RtspsSessionsGetParams) (res RtspsSessionsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/rtspssessions/get/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRtspsSessionsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RtspsSessionsKick invokes rtspsSessionsKick operation.
//
// Kicks out a RTSPS session from the server.
//
// POST /v3/rtspssessions/kick/{id}
func (c *Client) RtspsSessionsKick(ctx context.Context, params RtspsSessionsKickParams) (RtspsSessionsKickRes, error) {
	res, err := c.sendRtspsSessionsKick(ctx, params)
	return res, err
}

func (c *Client) sendRtspsSessionsKick(ctx context.Context, params RtspsSessionsKickParams) (res RtspsSessionsKickRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/rtspssessions/kick/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRtspsSessionsKickResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RtspsSessionsList invokes rtspsSessionsList operation.
//
// Returns all RTSPS sessions.
//
// GET /v3/rtspssessions/list
func (c *Client) RtspsSessionsList(ctx context.Context, params RtspsSessionsListParams) (RtspsSessionsListRes, error) {
	res, err := c.sendRtspsSessionsList(ctx, params)
	return res, err
}

func (c *Client) sendRtspsSessionsList(ctx context.Context, params RtspsSessionsListParams) (res RtspsSessionsListRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/rtspssessions/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "itemsPerPage" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ItemsPerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRtspsSessionsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SrtConnsGet invokes srtConnsGet operation.
//
// Returns a SRT connection.
//
// GET /v3/srtconns/get/{id}
func (c *Client) SrtConnsGet(ctx context.Context, params SrtConnsGetParams) (SrtConnsGetRes, error) {
	res, err := c.sendSrtConnsGet(ctx, params)
	return res, err
}

func (c *Client) sendSrtConnsGet(ctx context.Context, params SrtConnsGetParams) (res SrtConnsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/srtconns/get/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSrtConnsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SrtConnsKick invokes srtConnsKick operation.
//
// Kicks out a SRT connection from the server.
//
// POST /v3/srtconns/kick/{id}
func (c *Client) SrtConnsKick(ctx context.Context, params SrtConnsKickParams) (SrtConnsKickRes, error) {
	res, err := c.sendSrtConnsKick(ctx, params)
	return res, err
}

func (c *Client) sendSrtConnsKick(ctx context.Context, params SrtConnsKickParams) (res SrtConnsKickRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/srtconns/kick/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSrtConnsKickResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SrtConnsList invokes srtConnsList operation.
//
// Returns all SRT connections.
//
// GET /v3/srtconns/list
func (c *Client) SrtConnsList(ctx context.Context, params SrtConnsListParams) (SrtConnsListRes, error) {
	res, err := c.sendSrtConnsList(ctx, params)
	return res, err
}

func (c *Client) sendSrtConnsList(ctx context.Context, params SrtConnsListParams) (res SrtConnsListRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/srtconns/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "itemsPerPage" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ItemsPerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSrtConnsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WebrtcSessionsGet invokes webrtcSessionsGet operation.
//
// Returns a WebRTC session.
//
// GET /v3/webrtcsessions/get/{id}
func (c *Client) WebrtcSessionsGet(ctx context.Context, params WebrtcSessionsGetParams) (WebrtcSessionsGetRes, error) {
	res, err := c.sendWebrtcSessionsGet(ctx, params)
	return res, err
}

func (c *Client) sendWebrtcSessionsGet(ctx context.Context, params WebrtcSessionsGetParams) (res WebrtcSessionsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/webrtcsessions/get/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWebrtcSessionsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WebrtcSessionsKick invokes webrtcSessionsKick operation.
//
// Kicks out a WebRTC session from the server.
//
// POST /v3/webrtcsessions/kick/{id}
func (c *Client) WebrtcSessionsKick(ctx context.Context, params WebrtcSessionsKickParams) (WebrtcSessionsKickRes, error) {
	res, err := c.sendWebrtcSessionsKick(ctx, params)
	return res, err
}

func (c *Client) sendWebrtcSessionsKick(ctx context.Context, params WebrtcSessionsKickParams) (res WebrtcSessionsKickRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v3/webrtcsessions/kick/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWebrtcSessionsKickResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WebrtcSessionsList invokes webrtcSessionsList operation.
//
// Returns all WebRTC sessions.
//
// GET /v3/webrtcsessions/list
func (c *Client) WebrtcSessionsList(ctx context.Context, params WebrtcSessionsListParams) (WebrtcSessionsListRes, error) {
	res, err := c.sendWebrtcSessionsList(ctx, params)
	return res, err
}

func (c *Client) sendWebrtcSessionsList(ctx context.Context, params WebrtcSessionsListParams) (res WebrtcSessionsListRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v3/webrtcsessions/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "itemsPerPage" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ItemsPerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWebrtcSessionsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
